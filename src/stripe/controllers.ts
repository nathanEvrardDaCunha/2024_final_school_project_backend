import { Request, Response } from 'express';import Stripe from 'stripe';import { getLocationById, updateLocation } from '../location/repository';import { updateUserStatus } from '../dashboard/repository';import { LocationStatus, UserStatus } from '@prisma/client';if (!process.env.STRIPE_SECRET_KEY) {	throw new Error('Missing STRIPE_SECRET_KEY in environment variables');}const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {	apiVersion: '2024-06-20',});export const createCheckoutSessionController = async (req: Request, res: Response) => {	try {		const { locationId } = req.body;				const location = await getLocationById(locationId);				if (!location) {			return res.status(404).json({ error: 'Location not found' });		}				const session = await stripe.checkout.sessions.create({			payment_method_types: ['card'],			line_items: [				{					price: process.env.STRIPE_PRICE_ID,					quantity: 1,				},			],			mode: 'subscription',			success_url: `${process.env.FRONTEND_URL}/success?session_id={CHECKOUT_SESSION_ID}`,			cancel_url: `${process.env.FRONTEND_URL}/canceled`,			client_reference_id: locationId.toString(),		});				res.json({ id: session.id });	} catch (error) {		console.error('Error creating checkout session:', error);		res.status(500).json({ error: 'Failed to create checkout session' });	}};export const createSubscriptionCheckoutSessionController = async (req: Request, res: Response) => {	try {		const { planType, interval } = req.body;		const userId = (req as any).userId;				if (planType === 'DELETE') {			await updateUserStatus(userId, UserStatus.FREE);			return res.json({ success: true, message: 'Subscription cancelled. User status updated to FREE.' });		}				let priceId;		switch (`${planType}_${interval}`) {			case 'BAGPACKER_MONTHLY':				priceId = process.env.STRIPE_PRICE_BAGPACKER_MONTHLY_ID;				break;			case 'BAGPACKER_YEARLY':				priceId = process.env.STRIPE_PRICE_BAGPACKER_YEARLY_ID;				break;			case 'EXPLORATOR_MONTHLY':				priceId = process.env.STRIPE_PRICE_EXPLORATOR_MONTHLY_ID;				break;			case 'EXPLORATOR_YEARLY':				priceId = process.env.STRIPE_PRICE_EXPLORATOR_YEARLY_ID;				break;			default:				return res.status(400).json({ error: 'Invalid plan type or interval' });		}				const session = await stripe.checkout.sessions.create({			payment_method_types: ['card'],			line_items: [				{					price: priceId,					quantity: 1,				},			],			mode: 'subscription',			success_url: `${process.env.FRONTEND_URL}/success?session_id={CHECKOUT_SESSION_ID}`,			cancel_url: `${process.env.FRONTEND_URL}/canceled`,			client_reference_id: `${userId}:${planType}:${interval}`,		});				res.json({ id: session.id });	} catch (error) {		console.error('Error handling subscription action:', error);		res.status(500).json({ error: 'Failed to process subscription action' });	}};export const webhookHandler = async (req: Request, res: Response) => {	const sig = req.headers['stripe-signature'] as string;	let event: Stripe.Event;		console.log('Received webhook');		try {		event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET!);		console.log('Webhook event constructed:', event.type);	} catch (err: unknown) {		const errorMessage = err instanceof Error ? err.message : 'Unknown error';		console.error('Webhook Error:', errorMessage);		res.status(400).send(`Webhook Error: ${errorMessage}`);		return;	}		if (event.type === 'checkout.session.completed') {		console.log('Checkout session completed');		const session = event.data.object as Stripe.Checkout.Session;				if (session.client_reference_id) {			const [userId, planType, interval] = session.client_reference_id.split(':');			const referenceId = parseInt(userId);			console.log('Reference ID:', referenceId, 'Plan Type:', planType, 'Interval:', interval);						try {				if (session.mode === 'subscription') {					let newStatus: UserStatus;					switch (`${planType}_${interval}`) {						case 'BAGPACKER_MONTHLY':							newStatus = UserStatus.BAGPACKER_MONTHLY;							break;						case 'BAGPACKER_YEARLY':							newStatus = UserStatus.BAGPACKER_YEARLY;							break;						case 'EXPLORATOR_MONTHLY':							newStatus = UserStatus.EXPLORATOR_MONTHLY;							break;						case 'EXPLORATOR_YEARLY':							newStatus = UserStatus.EXPLORATOR_YEARLY;							break;						default:							throw new Error('Unknown subscription type');					}										await updateUserStatus(referenceId, newStatus);					console.log(`User ${referenceId} status updated to ${newStatus}`);				} else {					// Handle location update for non-subscription payments					const updatedLocation = await updateLocation(referenceId, { locationStatus: LocationStatus.BEFORE_ASSET_PAPER });					console.log(`Location ${referenceId} status updated to BEFORE_ASSET_PAPER:`, updatedLocation);				}			} catch (error) {				console.error(`Error updating status for ID ${referenceId}:`, error);			}		} else {			console.log('No client_reference_id found in session');		}	} else {		console.log('Event type not handled:', event.type);	}		res.json({ received: true });};