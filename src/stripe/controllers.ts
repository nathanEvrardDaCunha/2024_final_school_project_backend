import { Request, Response } from 'express';import Stripe from 'stripe';import { getLocationById, updateLocation } from '../location/repository';import { updateUserStatus } from '../dashboard/repository';import { LocationStatus, UserStatus } from '@prisma/client';if (!process.env.STRIPE_SECRET_KEY) {	throw new Error('Missing STRIPE_SECRET_KEY in environment variables');}const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {	apiVersion: '2024-06-20',});export const createCheckoutSessionController = async (req: Request, res: Response) => {	try {		const { locationId, type } = req.body;		const userId = (req as any).userId;				let session;				if (type === 'location') {			const location = await getLocationById(locationId);						if (!location) {				return res.status(404).json({ error: 'Location not found' });			}						session = await stripe.checkout.sessions.create({				payment_method_types: ['card'],				line_items: [					{						price_data: {							currency: 'usd',							product_data: {								name: 'Location Payment',							},							unit_amount: location.pricePerNight * 100, // Assuming price is in dollars, convert to cents						},						quantity: 1,					},				],				mode: 'payment',				success_url: `${process.env.FRONTEND_URL}/success?session_id={CHECKOUT_SESSION_ID}`,				cancel_url: `${process.env.FRONTEND_URL}/canceled`,				client_reference_id: `location:${locationId}`,			});		} else if (type === 'subscription') {			const { planType, interval } = req.body;						if (planType === 'DELETE') {				await updateUserStatus(userId, UserStatus.FREE);				return res.json({ success: true, message: 'Subscription cancelled. User status updated to FREE.' });			}						let priceId;			switch (`${planType}_${interval}`) {				case 'BAGPACKER_MONTHLY':					priceId = process.env.STRIPE_PRICE_BAGPACKER_MONTHLY_ID;					break;				case 'BAGPACKER_YEARLY':					priceId = process.env.STRIPE_PRICE_BAGPACKER_YEARLY_ID;					break;				case 'EXPLORATOR_MONTHLY':					priceId = process.env.STRIPE_PRICE_EXPLORATOR_MONTHLY_ID;					break;				case 'EXPLORATOR_YEARLY':					priceId = process.env.STRIPE_PRICE_EXPLORATOR_YEARLY_ID;					break;				default:					return res.status(400).json({ error: 'Invalid plan type or interval' });			}						session = await stripe.checkout.sessions.create({				payment_method_types: ['card'],				line_items: [					{						price: priceId,						quantity: 1,					},				],				mode: 'subscription',				success_url: `${process.env.FRONTEND_URL}/success?session_id={CHECKOUT_SESSION_ID}`,				cancel_url: `${process.env.FRONTEND_URL}/canceled`,				client_reference_id: `user:${userId}:${planType}:${interval}`,			});		} else {			return res.status(400).json({ error: 'Invalid checkout type' });		}				res.json({ id: session.id });	} catch (error) {		console.error('Error creating checkout session:', error);		res.status(500).json({ error: 'Failed to create checkout session' });	}};export const webhookHandler = async (req: Request, res: Response) => {	const sig = req.headers['stripe-signature'] as string;	let event: Stripe.Event;		console.log('Received webhook');		try {		event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET!);		console.log('Webhook event constructed:', event.type);	} catch (err: unknown) {		const errorMessage = err instanceof Error ? err.message : 'Unknown error';		console.error('Webhook Error:', errorMessage);		res.status(400).send(`Webhook Error: ${errorMessage}`);		return;	}		if (event.type === 'checkout.session.completed') {		console.log('Checkout session completed');		const session = event.data.object as Stripe.Checkout.Session;				if (session.client_reference_id) {			const [type, id, ...rest] = session.client_reference_id.split(':');						if (type === 'location') {				const locationId = parseInt(id);				console.log('Updating location:', locationId);								try {					const updatedLocation = await updateLocation(locationId, { locationStatus: LocationStatus.BEFORE_ASSET_PAPER });					console.log(`Location ${locationId} status updated to BEFORE_ASSET_PAPER:`, updatedLocation);				} catch (error) {					console.error(`Error updating location ${locationId} status:`, error);				}			} else if (type === 'user') {				const userId = parseInt(id);				const [planType, interval] = rest;				console.log('Updating user subscription:', userId, planType, interval);								try {					let newStatus: UserStatus;					switch (`${planType}_${interval}`) {						case 'BAGPACKER_MONTHLY':							newStatus = UserStatus.BAGPACKER_MONTHLY;							break;						case 'BAGPACKER_YEARLY':							newStatus = UserStatus.BAGPACKER_YEARLY;							break;						case 'EXPLORATOR_MONTHLY':							newStatus = UserStatus.EXPLORATOR_MONTHLY;							break;						case 'EXPLORATOR_YEARLY':							newStatus = UserStatus.EXPLORATOR_YEARLY;							break;						default:							throw new Error('Unknown subscription type');					}										await updateUserStatus(userId, newStatus);					console.log(`User ${userId} status updated to ${newStatus}`);				} catch (error) {					console.error(`Error updating user ${userId} status:`, error);				}			}		} else {			console.log('No client_reference_id found in session');		}	} else {		console.log('Unhandled event type:', event.type);	}		res.json({ received: true });};