import { PrismaClient, ServiceName, ServicePrice, Service, Avis } from '@prisma/client';import Stripe from 'stripe';const prisma = new PrismaClient();if (!process.env.STRIPE_SECRET_KEY) {	throw new Error('Missing STRIPE_SECRET_KEY in environment variables');}const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {	apiVersion: '2024-06-20',});const serviceNameToIndex = (name: ServiceName): number => {	return Object.values(ServiceName).indexOf(name);};const getServicePrice = (index: number): number => {	const prices = [20, 30, 40, 50, 60, 75, 80, 100, 120, 150, 200, 250, 300, 350, 400, 450, 500, 600, 750, 1000];	return prices[index] || 0;};export const createPaymentIntent = async (serviceId: ServiceName, reservationId: number) => {	const serviceIndex = serviceNameToIndex(serviceId);	const amount = getServicePrice(serviceIndex) * 100; // Convert to cents		const paymentIntent = await stripe.paymentIntents.create({		amount,		currency: 'usd',		metadata: { serviceId, reservationId: reservationId.toString() },	});		return paymentIntent.client_secret;};export const getServices = async (): Promise<Array<{ name: ServiceName; price: string }>> => {	return Object.values(ServiceName).map((name, index) => ({		name,		price: `$${getServicePrice(index)}`,	}));};export const getFreeServiceStatus = async (userId: number) => {	const user = await prisma.user.findUnique({ where: { id: userId } });	if (!user) throw new Error('User not found');		const isEligibleForFreeService =		(user.status === 'EXPLORATOR_MONTHLY' || user.status === 'EXPLORATOR_YEARLY' ||			user.status === 'BAGPACKER_MONTHLY' || user.status === 'BAGPACKER_YEARLY') &&		!user.freeServiceUsed;		return { freeServiceUsed: user.freeServiceUsed, isEligibleForFreeService };};export const bookService = async (serviceName: ServiceName, reservationId: number, userId: number) => {	const user = await prisma.user.findUnique({ where: { id: userId } });	if (!user) throw new Error('User not found');		const isEligibleForFreeService =		(user.status === 'EXPLORATOR_MONTHLY' || user.status === 'EXPLORATOR_YEARLY' ||			user.status === 'BAGPACKER_MONTHLY' || user.status === 'BAGPACKER_YEARLY') &&		!user.freeServiceUsed;		const serviceIndex = serviceNameToIndex(serviceName);	let servicePrice = Object.values(ServicePrice)[serviceIndex] as ServicePrice;		if (isEligibleForFreeService) {		servicePrice = ServicePrice.PRICE_O; 		await prisma.user.update({			where: { id: userId },			data: { freeServiceUsed: true },		});	}		return prisma.service.create({		data: {			name: serviceName,			price: servicePrice,			reservationId: reservationId,		},	});};export const getServicesWithAvis = async () => {	try {		const services = await prisma.service.findMany({			include: {				avis: true			}		});				return services.map(service => ({			id: service.id,			name: service.name,			price: `$${getServicePrice(serviceNameToIndex(service.name as ServiceName))}`,			avis: service.avis		}));	} catch (error) {		console.error('Error fetching services with avis:', error);		throw error;	}};export const createAvisService = async (userId: number, serviceId: number, reactivity: number, disponibility: number, quality: number) => {	const existingAvis = await prisma.avis.findFirst({		where: {			serviceId: serviceId,			service: {				reservation: {					userId: userId				}			}		}	});		if (existingAvis) {		throw new Error('User has already submitted an Avis for this service');	}		return prisma.avis.create({		data: {			reactivity,			disponibility,			quality,			service: { connect: { id: serviceId } },		}	});};export const deleteAvisService = async (userId: number, serviceId: number) => {	const avis = await prisma.avis.findFirst({		where: {			serviceId: serviceId,			service: {				reservation: {					userId: userId				}			}		}	});		if (!avis) {		throw new Error('Avis not found or user not authorized to delete this Avis');	}		return prisma.avis.delete({		where: { id: avis.id }	});};