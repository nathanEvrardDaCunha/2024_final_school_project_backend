import {PrismaClient, Location, Prisma, LocationStatus, DocumentStatus, Perk} from '@prisma/client';import {DefaultArgs, GetFindResult} from "@prisma/client/runtime/library";const prisma = new PrismaClient();export async function createLocation(locationData: Prisma.LocationCreateInput): Promise<Location> {	return prisma.location.create({		data: locationData,	});}export async function getLocationById(id: number): Promise<Location | null> {	return prisma.location.findUnique({		where: { id },	});}export async function updateLocation(id: number, data: Prisma.LocationUpdateInput): Promise<Location> {	return prisma.location.update({		where: { id },		data,	});}export async function deleteLocation(id: number): Promise<Location> {	return prisma.location.delete({		where: { id },	});}export async function getLocationsToReviewFromDB(): Promise<Location[]> {	return prisma.location.findMany({		where: {			locationStatus: {				in: [LocationStatus.BEFORE_ASSET_PAPER]			}		},		include: {			user: {				select: {					firstname: true,					lastname: true				}			},			documents: true		}	});}export async function getLocationFromDB(locationId: number): Promise<Location | null> {	return prisma.location.findUnique({		where: { id: locationId },		include: {			user: {				select: {					firstname: true,					lastname: true				}			},			documents: true,			perks: true		}	});}export async function addDocumentToLocationAsPaperAsset(locationId: number, documentData: {	file: Buffer;	filename: string;	documentType: "PAPER_ASSET";	documentStatus: "AVAILABLE"}): Promise<Prisma.DocumentGetPayload<{}>> {	return prisma.document.create({		data: {			file: documentData.file,			filename: documentData.filename,			documentType: documentData.documentType,			documentStatus: documentData.documentStatus,			location: {				connect: {					id: locationId				}			}		}	});}export async function addDocumentToLocationAsImage(locationId: number, documentData: {	file: Buffer;	filename: string;	documentType: "IMAGES";	documentStatus: "AVAILABLE"}): Promise<Prisma.DocumentGetPayload<{}>> {	return prisma.document.create({		data: {			file: documentData.file,			filename: documentData.filename,			documentType: documentData.documentType,			documentStatus: documentData.documentStatus,			location: {				connect: {					id: locationId				}			}		}	});}export async function updateLocationStatus(locationId: number, status: LocationStatus): Promise<Location> {	return prisma.location.update({		where: { id: locationId },		data: { locationStatus: status },		include: {			user: {				select: {					firstname: true,					lastname: true				}			},			documents: true		}	});}export async function removeDocumentFromDB(locationId: number, documentId: number): Promise<void> {	await prisma.document.deleteMany({		where: {			id: documentId,			locationId: locationId		}	});}export async function getLocationsPendingPublishFromDB(): Promise<Location[]> {	console.log('Entering getLocationsPendingPublishFromDB');	const locations = await prisma.location.findMany({		where: {			locationStatus: LocationStatus.BEFORE_PUBLISHING		},		include: {			user: {				select: {					firstname: true,					lastname: true				}			},			documents: true,			perks: true		}	});	console.log('Prisma query completed');	return locations;}export async function getPublishedLocationsFromDB(): Promise<GetFindResult<Prisma.$LocationPayload<DefaultArgs>, {	include: { documents: { take: number; where: { documentType: string } } };	where: { locationStatus: "PUBLISHED" }}, {}>[]> {	try {		return await prisma.location.findMany({			where: {				locationStatus: LocationStatus.PUBLISHED			},			include: {				documents: {					where: {						documentType: 'IMAGES'					},					take: 1				}			}		});	} catch (error) {		console.error('Error in getPublishedLocationsFromDB:', error);		throw error;	}}